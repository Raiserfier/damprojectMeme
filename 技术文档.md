# 技术文档
## 系统框架：Django+Vue前后端分离
### 前端框架（ly）
#### Vue Component 模块管理
#### Vue Router 路由架构
#### Vue Store 状态管理
### 后端框架（lxy）
#### 数据模型
[ER图]
## 主要功能
### 用户管理模块
#### 注册
#### 登录
#### 注销
#### 设置
### 表情管理模块
#### 上传
#### 搜索
#### 收藏
#### 推荐
#### 隐私管理
#### 版权管理
## 特殊设计
### 图片推荐：感知哈希算法（swx）

在这个项目中，表情包图片推荐的核心在于图片语义筛选以及图像本身的推荐。

- 图片语义筛选

  需求来源是用户对于**某一功能**的表情包的需求，比如，生气的表情包，展示风景的表情包，带有美食的表情包等等，这类需求的实现需要通过选择有着指定标签的图片并且比较图片与用户需求的契合度进行筛选。

- 图像筛选

  需求来源是用户对于某一类图片类型的会有**相对的偏好**，比如，黑白基调的表情包，颜色丰富的表情包等，这类偏好的满足需要通过对用户现有喜爱的图片的分析选择出合适的表情包进行推荐。

所以在我们的推荐算法会对用户收藏的图片标签和图像进行综合计算，找到最可能被用户继续喜欢的表情包。

相对于较简单的图片标签统计算法，值得一提的是在本项目中采用的用于检测图片相似度的**感知哈希算法**。

##### 感知哈希算法 PHA

哈希算法通过将单向数学函数应用到任意数量的数据所得到的固定大小结果。算法在接收一段输入数据后，会以一种不可逆的方式将其转化为一段长度较短、位数固定的散列数据。如果输入数据中有变化，则哈希也会发生变化（这也是密码学中常常提及的**雪崩效应**）。由于这一特性，哈希算法的结果具有特征识别能力。

将哈希算法应用于图像相似度比较中，采用的也是这样的一种**特征**思想。通过感知哈希算法给每张图片生成一个“指纹”，指纹越相似的两张图片它们的相似度就越高。

在感知哈希算法中，并没有以严格的方式计算Hash值，而是以更加相对的方式计算哈希值。它的基本步骤是缩小简化原图片-得到特征原始数据-计算哈希值。

![](https://www.mdpi.com/algorithms/algorithms-11-00006/article_deploy/html/images/algorithms-11-00006-g001.png)

这一算法也是谷歌以图识图搜索采用的一种算法。

感知哈希算法中有三种常用的算法，它们在特征数据的选择上有所不同。

- ahash

  主要利用了图片的低频信息

  > （1）缩小尺寸：去除高频和细节的最快方法是缩小图片，将图片缩小到8x8的尺寸，总共64个像素。不要保持纵横比，只需将其变成8*8的正方形。这样就可以比较任意大小的图片，摒弃不同尺寸、比例带来的图片差异。
  >
  > （2）简化色彩：将8*8的小图片转换成灰度图像。
  >
  > （3）计算平均值：计算所有64个像素的灰度平均值。
  >
  > （4）比较像素的灰度：将每个像素的灰度，与平均值进行比较。大于或等于平均值，记为1；小于平均值，记为0。
  >
  > （5）计算hash值：将上一步的比较结果，组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。组合的次序并不重要，只要保证所有图片都采用同样次序就行了。(我设置的是从左到右，从上到下用二进制保存)。

- phash

  是dhash的增强版，使用离散余弦变换(DCT)降低频率

  > 1）缩小尺寸：pHash以小图片开始，但图片大于8*8，32*32是最好的。这样做的目的是简化了DCT的计算，而不是减小频率。
  >
  > （2）简化色彩：将图片转化成灰度图像，进一步简化计算量。
  >
  > （3）计算DCT：计算图片的DCT变换，得到32*32的DCT系数矩阵。
  >
  > （4）缩小DCT：虽然DCT的结果是32X32大小的矩阵，但我们只要保留左上角的8*8的矩阵，这部分呈现了图片中的最低频率。
  >
  > （5）计算平均值：如同均值哈希一样，计算DCT的均值。
  >
  > （6）计算hash值：这是最主要的一步，根据8*8的DCT矩阵，设置0或1的64位的hash值，大于等于DCT均值的设为”1”，小于DCT均值的设为“0”。组合在一起，就构成了一个64位的整数，这就是这张图片的指纹。
  >

- dhash

  > 1.缩小图片：收缩到9*8的大小，一遍它有72的像素点
  >
  > 2.转化为灰度图：把缩放后的图片转化为256阶的灰度图。（具体算法见平均哈希算法步骤）
  >
  > 3.计算差异值：dHash算法工作在相邻像素之间，这样每行9个像素之间产生了8个不同的差异，一共8行，则产生了64个差异值
  >
  > 4.获得指纹：如果左边的像素比右边的更亮，则记录为1，否则为0.

在求解完每张图的hash值后，通过计算海明距离，距离越小则图片相似度越高。

本项目中采用的是最后一种感知哈希算法，相比前两种，它的计算速度更快（不需要计算平均数），并且在查阅资料后了解到它的精确度相比于其他两种也较高。

### 图片流（zbf）
